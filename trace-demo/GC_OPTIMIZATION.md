# GC 优化效果对比

## 测试配置

- **任务数量**: 50,000
- **每任务内存分配**: ~100KB
- **总内存分配**: ~5GB
- **CPU 核心数**: 10

## 性能对比数据

### 1. 单线程处理

```
执行时间: 2424ms
内存分配: 5078.90 MB
GC 次数:  606
GC 时间:  21.11ms (0.9%)
```

**特点**:
- ✅ GC 占比最低（0.9%）
- ❌ 执行时间最长
- 💡 适合作为性能基准

### 2. Fan-out 模式（GOGC=100）

```
执行时间: 818ms
内存分配: 5088.44 MB
GC 次数:  195
GC 时间:  30.66ms (3.7%)
```

**特点**:
- ✅ 并发度最高
- ⚠️ GC 压力较大（3.7%）
- ⚠️ 大量 goroutine 创建开销

### 3. Worker Pool（GOGC=100，默认）

```
执行时间: 570ms
内存分配: 5080.81 MB
GC 次数:  162
GC 时间:  26.79ms (4.7%)
```

**特点**:
- ✅ 控制并发数量
- ❌ GC 占比最高（4.7%）
- 💡 需要 GC 调优

### 4. Worker Pool Tuned（GOGC=1000，优化）⭐

```
执行时间: 427ms
内存分配: 5080.84 MB
GC 次数:  26
GC 时间:  7.54ms (1.8%)
```

**特点**:
- ✅ **最佳性能**
- ✅ GC 次数减少 84%（162 → 26）
- ✅ GC 时间占比降低 62%（4.7% → 1.8%）
- ✅ 整体性能提升 25%

## 关键洞察

### 1. GC 调优的重要性

| 指标 | GOGC=100 | GOGC=1000 | 改进 |
|------|----------|-----------|------|
| 执行时间 | 570ms | 427ms | **↓ 25%** |
| GC 次数 | 162 | 26 | **↓ 84%** |
| GC 时间 | 26.79ms | 7.54ms | **↓ 72%** |
| GC 占比 | 4.7% | 1.8% | **↓ 62%** |

### 2. GOGC 参数解释

**GOGC=100（默认）**:
- 堆增长 100% 时触发 GC
- 例如：当前堆 50MB，增长到 100MB 时触发 GC
- 优点：内存占用低
- 缺点：GC 频繁

**GOGC=1000（优化）**:
- 堆增长 1000% 时触发 GC
- 例如：当前堆 50MB，增长到 550MB 时触发 GC
- 优点：GC 次数少，性能高
- 缺点：内存占用高

### 3. 内存使用对比

| 模式 | 当前内存 | GC 次数 | 性能 |
|------|---------|---------|------|
| GOGC=100 | 50.44 MB | 162 | 基准 |
| GOGC=1000 | 56.44 MB | 26 | **快 25%** |

**结论**: 仅增加 6MB 内存（12%），性能提升 25%，非常值得！

## 可视化对比

### GC 次数对比

```
GOGC=100:  ████████████████████████████████████████ 162 次
GOGC=1000: ██████ 26 次 ✅ 减少 84%
```

### GC 时间占比

```
GOGC=100:  ████████████ 4.7%
GOGC=1000: ████ 1.8% ✅ 降低 62%
```

### 执行时间对比

```
单线程:    ████████████████████████ 2424ms
Fan-out:   ████████ 818ms
Pool:      ██████ 570ms
Pool+GC:   ████ 427ms ✅ 最快
```

## 实际应用建议

### 何时使用 GOGC=100（默认）

- ✅ 内存受限的环境
- ✅ 长时间运行的服务
- ✅ 需要稳定内存占用

### 何时使用 GOGC=1000（优化）

- ✅ 批处理任务
- ✅ 内存充足的环境
- ✅ 追求最佳性能
- ✅ 短时间运行的程序

### 何时使用 GOMEMLIMIT（推荐）

```bash
# 设置内存上限为 1GB
GOMEMLIMIT=1GiB go run .
```

**优点**:
- ✅ 语义更清晰（直接限制内存）
- ✅ 避免 OOM
- ✅ 自动调整 GC 频率

**示例**:
```bash
# 对比不同内存限制
GOMEMLIMIT=100MiB go run . -mode=pool -tasks=50000
GOMEMLIMIT=500MiB go run . -mode=pool -tasks=50000
GOMEMLIMIT=1GiB go run . -mode=pool -tasks=50000
```

## Trace 分析技巧

### 查看 GC 事件

```bash
# 生成 trace
go run . -mode=pool -tasks=50000 -trace=pool.trace

# 查看 trace
go tool trace pool.trace
```

**在 trace 界面中**:
1. 点击 "View trace"
2. 查看 "GC" 行
3. 观察 GC 频率和暂停时间

**对比 GOGC=100 和 GOGC=1000**:
- GOGC=100: GC 事件密集
- GOGC=1000: GC 事件稀疏

## 实验验证

### 实验 1: 不同 GOGC 值

```bash
for gogc in 50 100 200 500 1000 2000; do
    echo "GOGC=$gogc"
    GOGC=$gogc go run . -mode=pool -tasks=50000
done
```

**预期结果**:
- GOGC 越大，GC 次数越少
- GOGC 越大，内存占用越高
- 存在最佳平衡点（通常 500-1000）

### 实验 2: GOMEMLIMIT

```bash
for mem in 50MiB 100MiB 200MiB 500MiB 1GiB; do
    echo "GOMEMLIMIT=$mem"
    GOMEMLIMIT=$mem go run . -mode=pool -tasks=50000
done
```

### 实验 3: 对比 trace

```bash
# 生成两个 trace
go run . -mode=pool -tasks=50000 -trace=gc100.trace
GOGC=1000 go run . -mode=pool -tasks=50000 -trace=gc1000.trace

# 分别查看
go tool trace gc100.trace
go tool trace gc1000.trace
```

## 性能调优检查清单

- [ ] 使用 trace 查看 GC 频率
- [ ] 测试不同 GOGC 值
- [ ] 对比执行时间和内存占用
- [ ] 考虑使用 GOMEMLIMIT
- [ ] 在生产环境前进行压测
- [ ] 监控内存使用情况
- [ ] 设置合理的内存上限

## 总结

### 关键发现

1. **GC 是性能瓶颈**: Worker Pool 默认配置下，GC 占用 4.7% 的时间
2. **调优效果显著**: GOGC=1000 使性能提升 25%
3. **内存代价小**: 仅增加 12% 内存占用
4. **适用场景**: 批处理、数据处理、计算密集型任务

### 最佳实践

1. **开发阶段**: 使用默认 GOGC=100
2. **性能测试**: 尝试 GOGC=500-1000
3. **生产环境**: 使用 GOMEMLIMIT 限制内存
4. **监控**: 持续监控 GC 指标

### 推荐配置

```bash
# 批处理任务（追求性能）
GOGC=1000 go run .

# 长时间运行服务（稳定优先）
GOMEMLIMIT=1GiB go run .

# 内存受限环境
GOGC=50 GOMEMLIMIT=500MiB go run .
```

---

**记住**: 性能优化没有银弹，始终根据实际场景测试和调整！
